import math
import cmath
#import sys
#import time

class BasCenter:
    def __init__(self):
        self.expo = 1.0
        self.pos = (0.0, 0.0, 0.0)
        self.kvec = (0.0, 0.0, 0.0)
        self.angmom = []

    def __repr__(self):
        txt = '{expo = ' + str(self.expo)
        txt += ', r = (%f, %f, %f)' % self.pos
        txt += ', k = (%f, %f, %f)' % self.kvec
        L = [sum(amom) for amom in self.angmom]
        txt += ', lmin = %d, lmax = %d}' % (min(L), max(L))
        return txt

    def set_val_from_text(self, txt):
        # process one of the following type of statements
        #    expo = 5484.6717,
        #    pos = [0, -0.188, 0],
        #    kvec = [0.0094, 0, -0.0042]
        tok = txt.split('=')
        if len(tok) != 2:
            return False
        ident = tok[0].strip()
        valtok = tok[1].replace('[',' ').replace(']',' ')
        vtmp = [t.strip() for t in valtok.split(',')]
        val = tuple([float(v) for v in vtmp if len(v) > 0])

        allOK = False
        if ident == 'expo' and len(val) == 1:
            self.expo = val[0]
            allOK = True
        elif ident == 'pos' and len(val) == 3:
            self.pos = val
            allOK = True
        elif ident == 'kvec' and len(val) == 3:
            self.kvec = val
            allOK = True
        return allOK

    def add_angmom_from_text(self, txt):
        # process the following type of angular momentum specification
        #     basfun 0 <0, 0, 0>
        tok = txt.split('<')
        if len(tok) != 2:
            return False
        amom = tuple([int(t) for t in tok[1].replace('>','').split(',')])
        if len(amom) != 3:
            return False
        if min(amom) < 0 or max(amom) > 20:
            return False
        self.angmom.append(amom)
        return True

    def eval_basfun(self,r):
        """This function evaluates basis functions at a given point."""
        # loop over cartesian components
        bfval_comp = [[],[],[]]
        for c in range(3):
            relpos = r[c] - self.pos[c]
            dist2 = relpos * relpos
            w = complex(-self.expo * dist2, -self.kvec[c] * r[c])
            bfval_comp[c].append(cmath.exp(w))

            lmax = max([amom[c] for amom in self.angmom])
            for m in range(lmax+1):
                tmp = relpos * bfval_comp[c][-1]
                bfval_comp[c].append(tmp)
        # loop over angular momentum triple (effectively a loop over basis functions)
        bfval = []
        for amom in self.angmom:
            tmp = bfval_comp[0][amom[0]] * bfval_comp[1][amom[1]] * bfval_comp[2][amom[2]]
            bfval.append(tmp)
        return bfval

    def eval_basfun_deriv(self,r):
        """This function evaluates basis functions and their derivatives at a given point."""
        # loop over cartesian components
        bfval_comp = [[],[],[]]
        bfder_comp = [[],[],[]]
        for c in range(3):
            relpos = r[c] - self.pos[c]
            dist2 = relpos * relpos
            w = complex(-self.expo * dist2, -self.kvec[c] * r[c])
            bfval_comp[c].append(cmath.exp(w))

            lmax = max([amom[c] for amom in self.angmom])
            for m in range(1,lmax+1):
                tmp = relpos * bfval_comp[c][-1]
                bfval_comp[c].append(tmp)
            # d/dx (x-C)^m exp(-a(x-C)^2 - ikx) =
            #    m (x-C)^(m-1) exp(-a(x-C)^2 - ikx)
            #   -(2a(x-C)+ik) (x-C)^m exp(-a(x-C)^2 - ikx)
            fac = complex(2.0*self.expo*relpos, self.kvec[c])
            bfder_comp[c].append(-fac * bfval_comp[c][0])
            for m in range(1,lmax+1):
                tmp = m * bfval_comp[c][m-1] - fac * bfval_comp[c][m]
                bfder_comp[c].append(tmp)
        # loop over angular momentum triple (effectively a loop over basis functions)
        bfval = []
        bfder = []
        for amom in self.angmom:
            tmp = bfval_comp[0][amom[0]] * bfval_comp[1][amom[1]] * bfval_comp[2][amom[2]]
            bfval.append(tmp)
            tmpx = bfder_comp[0][amom[0]] * bfval_comp[1][amom[1]] * bfval_comp[2][amom[2]]
            tmpy = bfval_comp[0][amom[0]] * bfder_comp[1][amom[1]] * bfval_comp[2][amom[2]]
            tmpz = bfval_comp[0][amom[0]] * bfval_comp[1][amom[1]] * bfder_comp[2][amom[2]]
            bfder.append((tmpx, tmpy, tmpz))
        return bfval, bfder

def get_bas_dmat(filename):
    """This function extracts basis set information and a density matrix from a
    plain text file generated by the London program package."""
    f = open(filename,'r')

    basis = []
    dmat = []

    dmat_flag = False
    cen_flag = False
    center_def = []
    for line_raw in f:
        line = line_raw.strip()
        if len(line) < 1:
            continue

        assgn_flag = line.startswith('expo = ') or line.startswith('pos =') or line.startswith('kvec = ')
        angmom_flag = line.startswith('basfun')
        if dmat_flag and line.startswith(']'):
            # end of density matrix
            dmat_flag = False
        elif dmat_flag:
            l2 = line.replace('+-','-').replace('[',' ').replace(']',' ')
            delm = [complex(t) for t in l2.split(',') if len(t.strip()) > 0]
            dmat.append(delm)
        elif cen_flag and (assgn_flag or angmom_flag):
            center_def.append((line, assgn_flag, angmom_flag))
        elif len(center_def) > 0:
            cen_flag = False
            # process the stored lines of text, they should be a compete
            # definition of a center
            bc = BasCenter()
            for t in center_def:
                if t[1]:
                    rval = bc.set_val_from_text(t[0])
                else:
                    rval = bc.add_angmom_from_text(t[0])
                if not rval:
                    return None
            center_def = []
            basis.append(bc)

        if line.startswith('LCGTOCenter'):
            cen_flag = True
        elif line.startswith('DensPrim ='):
            dmat_flag = True

    # some error checking
    num_basfun = 0
    for cen in basis:
        num_basfun += len(cen.angmom)
    if len(dmat) != num_basfun:
        return None
    for r in range(len(dmat)):
        if len(dmat[r]) != num_basfun:
            return None
    # all done!
    return basis, dmat


def vdens(r,bas,d):
    """This function computes charge and current densities at a point in space."""

    nbf = len(d)

    # evaluate basis functions at r
    bf = []
    bfder = []
    for cen in bas:
        bf_cen, bfder_cen = cen.eval_basfun_deriv(r)
        bf.extend(bf_cen)
        bfder.extend(bfder_cen)

    if len(bf) != nbf or len(bfder) != nbf:
        return None

    # contract with density matrix
    bf_d = []
    for c in range(nbf):
        tmp = complex(0.0, 0.0)
        for r in range(nbf):
            tmp += bf[r] * d[r][c]
        bf_d.append(tmp)

    # electron density (number density)
    rho = 0.0
    for c in range(nbf):
        rho += (bf_d[c] * bf[c].conjugate()).real

    # current density (number current, not electrical current)
    pcan = [complex(0.0), complex(0.0), complex(0.0)]
    for c in range(nbf):
        pcan[0] += bf_d[c] * bfder[c][0].conjugate()
        pcan[1] += bf_d[c] * bfder[c][1].conjugate()
        pcan[2] += bf_d[c] * bfder[c][2].conjugate()
    grad_rho = (2.0 * pcan[0].real, 2.0 * pcan[1].real, 2.0 * pcan[2].real)
    jp = (-pcan[0].imag, -pcan[1].imag, -pcan[2].imag)

    return rho, grad_rho, jp

if __name__ == '__main__':
    basis, dmat = get_bas_dmat('density.txt')
    for k in range(len(basis)):
        print('center #', k, basis[k])

    for k in range(len(dmat)):
        print('D(%d,*) = ... %d elem...' % (k,len(dmat[k])))


    r = (0.01, -0.2, 0.1)
    rho, grad_rho, jp = vdens(r,basis,dmat)
    print('r = ',r)
    print('rho(r) = ',rho)
    print('grad(rho(r)) = ',grad_rho)
    print('jp(r) = ',jp)

    r = (0.0, 0.0, 0.0)
    rho, grad_rho, jp = vdens(r,basis,dmat)
    print('\nr = ',r)
    print('rho(r) = ',rho)
    print('grad(rho(r)) = ',grad_rho)
    print('jp(r) = ',jp)
